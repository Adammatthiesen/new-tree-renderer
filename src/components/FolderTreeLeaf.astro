---
import { Icon } from "studiocms:ui/components/icon";
import type { AvailableIcons } from "studiocms:ui/icons";
import type { NodeLeafProps } from "./shared";

interface Props extends NodeLeafProps {}

const { node, depth = 0 } = Astro.props;

/**
 * Determine the appropriate icon based on page data
 */
function getPageIcon(): AvailableIcons {
    if (!node.pageData) return "heroicons:document-text";

    if (node.pageData.slug === "index") {
        return "heroicons:home-modern";
    }

    if (node.pageData.draft) {
        return "heroicons:pencil";
    }

    return "heroicons:document-text";
}

const icon = getPageIcon();
const activeIcon = `${icon}-solid` as AvailableIcons;
const href = node.page ? `?edit=${node.id}` : "#";
---

<folder-tree-leaf
    data-node-id={node.id}
    data-depth={depth}
    data-href={href}
    class="tree-leaf"
    role="treeitem"
    tabindex="0"
>
    <Icon name={icon} class="leaf-icon default" width={20} height={20} />
    <Icon name={activeIcon} class="leaf-icon active" width={20} height={20} />
    <span class="tree-leaf-label">{node.name}</span>
    {node.pageData?.draft && <span class="leaf-badge draft-badge">Draft</span>}
    <div id={`${node.id}-context-menu`} class="context-menu" role="menu">
        <button class="context-menu-item" role="menuitem" data-action="edit">
            <Icon name="heroicons:pencil" width={16} height={16} />
            <span>Edit Page</span>
        </button>
    </div>
</folder-tree-leaf>

<script>
    class FolderTreeLeaf extends HTMLElement {
        private href: string;
        private contextMenu: HTMLElement | null = null;

        constructor() {
            super();
            this.href = this.getAttribute("data-href") || "#";
        }

        connectedCallback() {
            this.setAttribute("role", "link");
            this.contextMenu = this.querySelector(
                `#${this.getAttribute("data-node-id")}-context-menu`,
            );
            this.setupActiveState();
            this.setupEventListeners();
            this.setupContextMenu();
        }

        setupActiveState() {
            // Icons live in light DOM (projected via slot)
            const notSelectedIcon = this.querySelector(".not-selected");
            const selectedIcon = this.querySelector(".selected");

            let hrefEdit = null;
            try {
                hrefEdit = new URL(
                    this.getAttribute("href") || this.href || "#",
                    window.location.origin,
                ).searchParams.get("edit");
            } catch {}
            const currentEdit = new URL(window.location.href).searchParams.get(
                "edit",
            );

            const isActive =
                hrefEdit !== null &&
                currentEdit !== null &&
                hrefEdit === currentEdit;

            this.classList.toggle("active", !!isActive);
            if (notSelectedIcon)
                (notSelectedIcon as HTMLElement).style.display = isActive
                    ? "none"
                    : "block";
            if (selectedIcon)
                (selectedIcon as HTMLElement).style.display = isActive
                    ? "block"
                    : "none";
            if (isActive) {
                this.setAttribute("aria-current", "page");
            } else {
                this.removeAttribute("aria-current");
            }
        }

        setupEventListeners() {
            this.addEventListener("click", (event) => {
                const e = event as MouseEvent;

                if (this.href === "#") return;

                const openInNewTab = e.ctrlKey || e.metaKey || e.button === 1;

                e.preventDefault();

                if (openInNewTab) {
                    window.open(this.href, "_blank");
                } else {
                    window.location.href = this.href;
                }
            });

            this.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    this.click();
                }
            });
        }

        setupContextMenu() {
            // Show context menu on right-click
            this.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                this.showContextMenu(e as MouseEvent);
            });

            // Hide context menu when clicking outside
            document.addEventListener("click", (e) => {
                if (
                    this.contextMenu &&
                    !this.contextMenu.contains(e.target as Node)
                ) {
                    this.hideContextMenu();
                }
            });

            // Handle context menu actions
            const menuItems =
                this.contextMenu?.querySelectorAll(".context-menu-item");
            menuItems?.forEach((item) => {
                item.addEventListener("click", (e) => {
                    e.stopPropagation();
                    const action = (item as HTMLElement).getAttribute(
                        "data-action",
                    );
                    this.handleContextMenuAction(action);
                    this.hideContextMenu();
                });
            });

            // Close menu on Escape key
            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape") {
                    this.hideContextMenu();
                }
            });
        }

        showContextMenu(e: MouseEvent) {
            if (!this.contextMenu) return;

            // Position the menu at cursor
            this.contextMenu.style.left = `${e.pageX}px`;
            this.contextMenu.style.top = `${e.pageY}px`;
            this.contextMenu.classList.add("active");

            // Adjust if menu goes off-screen
            requestAnimationFrame(() => {
                if (!this.contextMenu) return;
                const rect = this.contextMenu.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                if (rect.right > viewportWidth) {
                    this.contextMenu.style.left = `${e.pageX - rect.width}px`;
                }

                if (rect.bottom > viewportHeight) {
                    this.contextMenu.style.top = `${e.pageY - rect.height}px`;
                }
            });
        }

        hideContextMenu() {
            this.contextMenu?.classList.remove("active");
        }

        handleContextMenuAction(action: string | null) {
            const href = this.getAttribute("data-href");

            switch (action) {
                case "edit":
                    if (href && href !== "#") {
                        const url = new URL(href, window.location.origin);
                        window.location.href = url.href;
                    }
                    break;
            }
        }
    }

    if (!customElements.get("folder-tree-leaf")) {
        customElements.define("folder-tree-leaf", FolderTreeLeaf);
    }
</script>
